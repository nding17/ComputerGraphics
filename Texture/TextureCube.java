/* Swing library */import java.awt.*;import java.awt.event.*;import java.awt.image.*;import java.io.*;import javax.imageio.*;import javax.swing.*;import java.util.*;// since the mapping textures on cube is// slightly more complicated. I decided to// create a texture class for the cube// main mapping method: bilinear mapping,// which requires we use UV coordinate systempublic class TextureCube{      // the size of the buffered image is fixed    public final static double WIDTH = 512;   public final static double HEIGHT = 512;   double[][] vertices; // vertices that passed down from cube class      // default image is where texture image comes from   // buffered image is where we draw the actual texture   BufferedImage bufferedImg, defaultImg;      /* TextureCube constructor */   public TextureCube(BufferedImage bi, double[][] v, String tfn){      // reserve memory for texture image		defaultImg = new BufferedImage(600, 600, BufferedImage.TYPE_INT_RGB);            // open up a file and read in the image      try{         defaultImg = ImageIO.read(new File(tfn));      }catch(IOException e){         e.printStackTrace();      }            /* initilization for vertices and buffered image */       vertices = v;      bufferedImg = bi;   }      // x and y coordinates are in normal coordinates    // system. (0,0) represents the top left corner   // and (600,600) represents the bottom right corner    // UV coordinates is the texture coordinates    // function that translate XY coordinates to UV   // coordinates    public double[] XYtoUV(double[] XY){         double x = XY[0];      double y = XY[1];            double u = x / WIDTH;      double v = (HEIGHT - y) / HEIGHT;            return new double[]{u,v};      }      // function that translate XY coordinates to UV   // coordinates   public double[] UVtoXY(double[] UV){         double u = UV[0];      double v = UV[1];            double x = u*WIDTH;      double y = HEIGHT - v*HEIGHT;            return new double[]{x,y};         }      // scaling for 2D vectors   public double[] multi(double a, double[] v){      return new double[]{v[0]*a, v[1]*a};   }      // addition for 2D vectors   public double[] add(double[] v, double[] w){      return new double[]{v[0]+w[0], v[1]+w[1]};   }      // bilinear mapping    // we are taking in the uv coordinates in the    // texture image and translate them to the    // buffered image where textures are drawn   // a new uv coordinate will be returned    public double[] f(double[] uv){            // 4 vertices for each face       // note that they are all in XY      // coordinate system      double[][] P = new double[4][2];      double u = uv[0];      double v = uv[1];            // we want to first translate XY      // unit to UV unit       for(int i = 0; i < P.length; i++){         P[i] = XYtoUV(vertices[i]);      }            // then we can figure out each individual       // pixel of the image that sent to the       // cubic face       double[] np0 = multi( (1-u)*(1-v), P[0] );      double[] np1 = multi( (1-v)*u, P[1] );      double[] np2 = multi( u*v, P[2] );      double[] np3 = multi( v*(1-u), P[3] );            double[] fuv = add(np0, np1);            fuv = add(fuv, np2);      fuv = add(fuv, np3);            return fuv;         }// end f      // crop the default image    public BufferedImage cropImage(BufferedImage src, Rectangle rect){      BufferedImage dest = src.getSubimage(0, 0, rect.width, rect.height);      return dest;   }      // main method for cubic texture mapping   public void mapTexture(){      // first crop a given size of image from the texture image if       // the texture is too big       BufferedImage croppedImg = cropImage(defaultImg, new Rectangle(512,512));                  for(int x = 0; x < croppedImg.getWidth(); x++){         for(int y = 0; y < croppedImg.getHeight(); y++){            // grab each pixel on the buffered image and             // transform them into uv coordinate system            double[] uv = XYtoUV(new double[]{x,y});            // figure out where it should end up in the            // texture image             double[] fuv = f(uv);            // accordingly, we know the xy of that pixel            // in the texture image             double[] nXY = UVtoXY(fuv);                        double nx = nXY[0];            double ny = nXY[1];               // now map the pixel on the face             bufferedImg.setRGB( (int)nx, (int)ny, croppedImg.getRGB(x,y));         }// end y loop      }// end x loop   }// end mapTexture   }